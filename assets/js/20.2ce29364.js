(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{294:function(a,t,s){"use strict";s.r(t);var _=s(13),r=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[a._v("#")]),a._v(" Tcp")]),a._v(" "),t("p",[a._v("Tcp 主要围绕几个问题展开：顺序问题、丢包问题、面向连接、流量控制、拥塞控制")]),a._v(" "),t("h2",{attrs:{id:"报文结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#报文结构"}},[a._v("#")]),a._v(" 报文结构")]),a._v(" "),t("h3",{attrs:{id:"源端口、目标端口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源端口、目标端口"}},[a._v("#")]),a._v(" 源端口、目标端口")]),a._v(" "),t("p",[a._v("Tcp 需要知道应用的端口才能在两个应用之间传输数据包")]),a._v(" "),t("h3",{attrs:{id:"序号、确认序号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#序号、确认序号"}},[a._v("#")]),a._v(" 序号、确认序号")]),a._v(" "),t("p",[a._v("数据从客户端传输到服务端后，服务端会基于序号做数据包排序以及丢包确认、并且会通过确认序号反馈给客户端数据的接受情况（累计应答）。")]),a._v(" "),t("h3",{attrs:{id:"状态位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#状态位"}},[a._v("#")]),a._v(" 状态位")]),a._v(" "),t("p",[a._v("Tcp 是面向链接的协议，会通过不同的状态位来更变通信之间的状态。常见的三次握手和四次挥手就是通过不同的状态位来改变客户端和服务端之间的状态")]),a._v(" "),t("h3",{attrs:{id:"窗口大小"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#窗口大小"}},[a._v("#")]),a._v(" 窗口大小")]),a._v(" "),t("p",[a._v("流量控制和拥塞控制主要通过调节窗口大小来控制传输的速度。")]),a._v(" "),t("h3",{attrs:{id:"紧急指针、校验和、保留位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#紧急指针、校验和、保留位"}},[a._v("#")]),a._v(" 紧急指针、校验和、保留位")]),a._v(" "),t("p",[a._v("暂无")]),a._v(" "),t("h2",{attrs:{id:"三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[a._v("#")]),a._v(" 三次握手")]),a._v(" "),t("ol",[t("li",[a._v("客户端向服务端发送 syn 报文")]),a._v(" "),t("li",[a._v("服务接受到报文后确认客户端具备发送能力，然后服务端发送 syn 和 ack 报文给客户端")]),a._v(" "),t("li",[a._v("客户端收到服务端的 syn 和 ack，确认服务端具备发送和接收的能力")])]),a._v(" "),t("h2",{attrs:{id:"四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[a._v("#")]),a._v(" 四次挥手")]),a._v(" "),t("ol",[t("li",[a._v("客户端向服务端发送 fin 报文，表示断开链接并进入 fin_wait_1 状态")]),a._v(" "),t("li",[a._v("服务端收到 fin 后，回复 ack，并进入 close-wait 半关闭状态")]),a._v(" "),t("li",[a._v("等待服务端发送完数据后，向客户端发送 fin 报文")]),a._v(" "),t("li",[a._v("客户端收到 fin 后进入 fin_wait_2 状态，同时回复 ack 客户端进入 time_wait 状态，服务端关闭链接，客户端并等待 2MSL 时间（报文最大生存时间）确认对方已经断开（防止 ack 丢包），再进入 close 状态")])]),a._v(" "),t("h2",{attrs:{id:"丢包问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#丢包问题"}},[a._v("#")]),a._v(" 丢包问题")]),a._v(" "),t("p",[a._v("为防止丢包，客户端和服务端都会在本地有一个缓存用来记录数据包的 id。\n客户端分为 4 部分，已发送已确认的、已发送未确认的、未发送可以发送的、未发送且不送发送的\n服务端分为 3 部分，已接收已处理的、已接收未处理的、未接收且无法接收的")]),a._v(" "),t("p",[a._v("每个发送后的数据包都会有一个定时器，当数据包超过往返时间 RTT 后，就会进行超时重发。当客户端发送 1、2、3 数据包，1、3 的数据包 ack 已经收到，2 的没收到，可能服务端没收到也可能服务端收到了\n但是 ack 的中途丢包了，这时客户端判断时间超过了 RTT 就会重发数据 2")]),a._v(" "),t("h2",{attrs:{id:"流量控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[a._v("#")]),a._v(" 流量控制")]),a._v(" "),t("p",[a._v("流量控制是为了防止客户端发送数据过快导致服务端本地的缓存溢出，所以要根据服务端处理数据的能力给一个合适的窗口大小控制发送数据的速度。")]),a._v(" "),t("h2",{attrs:{id:"拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[a._v("#")]),a._v(" 拥塞控制")]),a._v(" "),t("p",[a._v("拥塞控制是会根据当前的网络环境来调整窗口大小使数据包发送过快或过慢。TCP 会根据 BBR 拥塞算法，计算发送速度，当网络环境不好时，发送数据过快会导致数据丢包和重传。网络环境好时，发送过慢也会出现资源浪费")])])}),[],!1,null,null,null);t.default=r.exports}}]);